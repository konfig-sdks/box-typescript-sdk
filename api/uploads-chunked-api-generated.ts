/* tslint:disable */
/* eslint-disable */
/*
Box Platform API

[Box Platform](https://box.dev) provides functionality to provide access to content stored within [Box](https://box.com). It provides endpoints for basic manipulation of files and folders, management of users within an enterprise, as well as more complex topics such as legal holds and retention policies.

The version of the OpenAPI document: 2.0.0
Contact: devrel@box.com

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ClientError } from '../models';
// @ts-ignore
import { Files } from '../models';
// @ts-ignore
import { UploadPart } from '../models';
// @ts-ignore
import { UploadParts } from '../models';
// @ts-ignore
import { UploadSession } from '../models';
// @ts-ignore
import { UploadedPart } from '../models';
// @ts-ignore
import { UploadsChunkedCommitSessionRequest } from '../models';
// @ts-ignore
import { UploadsChunkedCreateSessionForUploadRequest } from '../models';
// @ts-ignore
import { UploadsChunkedCreateSessionForUploadRequest1 } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * UploadsChunkedApi - axios parameter creator
 * @export
 */
export const UploadsChunkedApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Close an upload session and create a file from the uploaded chunks.
         * @summary Commit upload session
         * @param {string} uploadSessionId The ID of the upload session.
         * @param {string} digest The [RFC3230][1] message digest of the whole file.  Only SHA1 is supported. The SHA1 digest must be Base64 encoded. The format of this header is as &#x60;sha&#x3D;BASE64_ENCODED_DIGEST&#x60;.  [1]: https://tools.ietf.org/html/rfc3230
         * @param {string} [ifMatch] Ensures this item hasn\&#39;t recently changed before making changes.  Pass in the item\&#39;s last observed &#x60;etag&#x60; value into this header and the endpoint will fail with a &#x60;412 Precondition Failed&#x60; if it has changed since.
         * @param {string} [ifNoneMatch] Ensures an item is only returned if it has changed.  Pass in the item\&#39;s last observed &#x60;etag&#x60; value into this header and the endpoint will fail with a &#x60;304 Not Modified&#x60; if the item has not changed since.
         * @param {UploadsChunkedCommitSessionRequest} [uploadsChunkedCommitSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitSession: async (uploadSessionId: string, digest: string, ifMatch?: string, ifNoneMatch?: string, uploadsChunkedCommitSessionRequest?: UploadsChunkedCommitSessionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadSessionId' is not null or undefined
            assertParamExists('commitSession', 'uploadSessionId', uploadSessionId)
            // verify required parameter 'digest' is not null or undefined
            assertParamExists('commitSession', 'digest', digest)
            const localVarPath = `/files/upload_sessions/{upload_session_id}/commit`
                .replace(`{${"upload_session_id"}}`, encodeURIComponent(String(uploadSessionId !== undefined ? uploadSessionId : `-upload_session_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)
            if (digest != null) {
                localVarHeaderParameter['digest'] = String(digest);
            }

            if (ifMatch != null) {
                localVarHeaderParameter['if-match'] = String(ifMatch);
            }

            if (ifNoneMatch != null) {
                localVarHeaderParameter['if-none-match'] = String(ifNoneMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: uploadsChunkedCommitSessionRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files/upload_sessions/{upload_session_id}/commit',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(uploadsChunkedCommitSessionRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an upload session for a new file.
         * @summary Create upload session
         * @param {UploadsChunkedCreateSessionForUploadRequest} [uploadsChunkedCreateSessionForUploadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSessionForUpload: async (uploadsChunkedCreateSessionForUploadRequest?: UploadsChunkedCreateSessionForUploadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files/upload_sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: uploadsChunkedCreateSessionForUploadRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files/upload_sessions',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(uploadsChunkedCreateSessionForUploadRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an upload session for an existing file.
         * @summary Create upload session for existing file
         * @param {string} fileId The unique identifier that represents a file.  The ID for any file can be determined by visiting a file in the web application and copying the ID from the URL. For example, for the URL &#x60;https://_*.app.box.com/files/123&#x60; the &#x60;file_id&#x60; is &#x60;123&#x60;.
         * @param {UploadsChunkedCreateSessionForUploadRequest1} [uploadsChunkedCreateSessionForUploadRequest1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSessionForUpload_1: async (fileId: string, uploadsChunkedCreateSessionForUploadRequest1?: UploadsChunkedCreateSessionForUploadRequest1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('createSessionForUpload_1', 'fileId', fileId)
            const localVarPath = `/files/{file_id}/upload_sessions`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId !== undefined ? fileId : `-file_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: uploadsChunkedCreateSessionForUploadRequest1,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files/{file_id}/upload_sessions',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(uploadsChunkedCreateSessionForUploadRequest1, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a chunk of an upload session for a file.
         * @summary Upload part of file
         * @param {string} uploadSessionId The ID of the upload session.
         * @param {string} digest The [RFC3230][1] message digest of the chunk uploaded.  Only SHA1 is supported. The SHA1 digest must be base64 encoded. The format of this header is as &#x60;sha&#x3D;BASE64_ENCODED_DIGEST&#x60;.  To get the value for the &#x60;SHA&#x60; digest, use the openSSL command to encode the file part: &#x60;openssl sha1 -binary &lt;FILE_PART_NAME&gt; | base64&#x60;  [1]: https://tools.ietf.org/html/rfc3230
         * @param {string} contentRange The byte range of the chunk.  Must not overlap with the range of a part already uploaded this session. Each part’s size must be exactly equal in size to the part size specified in the upload session that you created. One exception is the last part of the file, as this can be smaller.  When providing the value for &#x60;content-range&#x60;, remember that:  * The lower bound of each part\&#39;s byte range   must be a multiple of the part size. * The higher bound must be a multiple of the part size - 1.
         * @param {Uint8Array | File | buffer.File} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filePartUpdate: async (uploadSessionId: string, digest: string, contentRange: string, body?: Uint8Array | File | buffer.File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadSessionId' is not null or undefined
            assertParamExists('filePartUpdate', 'uploadSessionId', uploadSessionId)
            // verify required parameter 'digest' is not null or undefined
            assertParamExists('filePartUpdate', 'digest', digest)
            // verify required parameter 'contentRange' is not null or undefined
            assertParamExists('filePartUpdate', 'contentRange', contentRange)
            const localVarPath = `/files/upload_sessions/{upload_session_id}`
                .replace(`{${"upload_session_id"}}`, encodeURIComponent(String(uploadSessionId !== undefined ? uploadSessionId : `-upload_session_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)
            if (digest != null) {
                localVarHeaderParameter['digest'] = String(digest);
            }

            if (contentRange != null) {
                localVarHeaderParameter['content-range'] = String(contentRange);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: body,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files/upload_sessions/{upload_session_id}',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return information about an upload session.
         * @summary Get upload session
         * @param {string} uploadSessionId The ID of the upload session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        info: async (uploadSessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadSessionId' is not null or undefined
            assertParamExists('info', 'uploadSessionId', uploadSessionId)
            const localVarPath = `/files/upload_sessions/{upload_session_id}`
                .replace(`{${"upload_session_id"}}`, encodeURIComponent(String(uploadSessionId !== undefined ? uploadSessionId : `-upload_session_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files/upload_sessions/{upload_session_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of the chunks uploaded to the upload session so far.
         * @summary List parts
         * @param {string} uploadSessionId The ID of the upload session.
         * @param {number} [offset] The offset of the item at which to begin the response.  Queries with offset parameter value exceeding 10000 will be rejected with a 400 response.
         * @param {number} [limit] The maximum number of items to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listParts: async (uploadSessionId: string, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadSessionId' is not null or undefined
            assertParamExists('listParts', 'uploadSessionId', uploadSessionId)
            const localVarPath = `/files/upload_sessions/{upload_session_id}/parts`
                .replace(`{${"upload_session_id"}}`, encodeURIComponent(String(uploadSessionId !== undefined ? uploadSessionId : `-upload_session_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files/upload_sessions/{upload_session_id}/parts',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Abort an upload session and discard all data uploaded.  This cannot be reversed.
         * @summary Remove upload session
         * @param {string} uploadSessionId The ID of the upload session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUploadSession: async (uploadSessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadSessionId' is not null or undefined
            assertParamExists('removeUploadSession', 'uploadSessionId', uploadSessionId)
            const localVarPath = `/files/upload_sessions/{upload_session_id}`
                .replace(`{${"upload_session_id"}}`, encodeURIComponent(String(uploadSessionId !== undefined ? uploadSessionId : `-upload_session_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files/upload_sessions/{upload_session_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadsChunkedApi - functional programming interface
 * @export
 */
export const UploadsChunkedApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadsChunkedApiAxiosParamCreator(configuration)
    return {
        /**
         * Close an upload session and create a file from the uploaded chunks.
         * @summary Commit upload session
         * @param {UploadsChunkedApiCommitSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commitSession(requestParameters: UploadsChunkedApiCommitSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Files>> {
            const uploadsChunkedCommitSessionRequest: UploadsChunkedCommitSessionRequest = {
                parts: requestParameters.parts
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.commitSession(requestParameters.uploadSessionId, requestParameters.digest, requestParameters.ifMatch, requestParameters.ifNoneMatch, uploadsChunkedCommitSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates an upload session for a new file.
         * @summary Create upload session
         * @param {UploadsChunkedApiCreateSessionForUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSessionForUpload(requestParameters: UploadsChunkedApiCreateSessionForUploadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadSession>> {
            const uploadsChunkedCreateSessionForUploadRequest: UploadsChunkedCreateSessionForUploadRequest = {
                folder_id: requestParameters.folder_id,
                file_size: requestParameters.file_size,
                file_name: requestParameters.file_name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSessionForUpload(uploadsChunkedCreateSessionForUploadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates an upload session for an existing file.
         * @summary Create upload session for existing file
         * @param {UploadsChunkedApiCreateSessionForUpload0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSessionForUpload_1(requestParameters: UploadsChunkedApiCreateSessionForUpload0Request, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadSession>> {
            const uploadsChunkedCreateSessionForUploadRequest1: UploadsChunkedCreateSessionForUploadRequest1 = {
                file_size: requestParameters.file_size,
                file_name: requestParameters.file_name
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSessionForUpload_1(requestParameters.fileId, uploadsChunkedCreateSessionForUploadRequest1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a chunk of an upload session for a file.
         * @summary Upload part of file
         * @param {UploadsChunkedApiFilePartUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filePartUpdate(requestParameters: UploadsChunkedApiFilePartUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadedPart>> {
            const body: Uint8Array | File | buffer.File = requestParameters.requestBody;
            const localVarAxiosArgs = await localVarAxiosParamCreator.filePartUpdate(requestParameters.uploadSessionId, requestParameters.digest, requestParameters.contentRange, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return information about an upload session.
         * @summary Get upload session
         * @param {UploadsChunkedApiInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async info(requestParameters: UploadsChunkedApiInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.info(requestParameters.uploadSessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return a list of the chunks uploaded to the upload session so far.
         * @summary List parts
         * @param {UploadsChunkedApiListPartsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listParts(requestParameters: UploadsChunkedApiListPartsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadParts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listParts(requestParameters.uploadSessionId, requestParameters.offset, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Abort an upload session and discard all data uploaded.  This cannot be reversed.
         * @summary Remove upload session
         * @param {UploadsChunkedApiRemoveUploadSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUploadSession(requestParameters: UploadsChunkedApiRemoveUploadSessionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUploadSession(requestParameters.uploadSessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UploadsChunkedApi - factory interface
 * @export
 */
export const UploadsChunkedApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadsChunkedApiFp(configuration)
    return {
        /**
         * Close an upload session and create a file from the uploaded chunks.
         * @summary Commit upload session
         * @param {UploadsChunkedApiCommitSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitSession(requestParameters: UploadsChunkedApiCommitSessionRequest, options?: AxiosRequestConfig): AxiosPromise<Files> {
            return localVarFp.commitSession(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an upload session for a new file.
         * @summary Create upload session
         * @param {UploadsChunkedApiCreateSessionForUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSessionForUpload(requestParameters: UploadsChunkedApiCreateSessionForUploadRequest, options?: AxiosRequestConfig): AxiosPromise<UploadSession> {
            return localVarFp.createSessionForUpload(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an upload session for an existing file.
         * @summary Create upload session for existing file
         * @param {UploadsChunkedApiCreateSessionForUpload0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSessionForUpload_1(requestParameters: UploadsChunkedApiCreateSessionForUpload0Request, options?: AxiosRequestConfig): AxiosPromise<UploadSession> {
            return localVarFp.createSessionForUpload_1(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a chunk of an upload session for a file.
         * @summary Upload part of file
         * @param {UploadsChunkedApiFilePartUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filePartUpdate(requestParameters: UploadsChunkedApiFilePartUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<UploadedPart> {
            return localVarFp.filePartUpdate(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Return information about an upload session.
         * @summary Get upload session
         * @param {UploadsChunkedApiInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        info(requestParameters: UploadsChunkedApiInfoRequest, options?: AxiosRequestConfig): AxiosPromise<UploadSession> {
            return localVarFp.info(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of the chunks uploaded to the upload session so far.
         * @summary List parts
         * @param {UploadsChunkedApiListPartsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listParts(requestParameters: UploadsChunkedApiListPartsRequest, options?: AxiosRequestConfig): AxiosPromise<UploadParts> {
            return localVarFp.listParts(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Abort an upload session and discard all data uploaded.  This cannot be reversed.
         * @summary Remove upload session
         * @param {UploadsChunkedApiRemoveUploadSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUploadSession(requestParameters: UploadsChunkedApiRemoveUploadSessionRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeUploadSession(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for commitSession operation in UploadsChunkedApi.
 * @export
 * @interface UploadsChunkedApiCommitSessionRequest
 */
export type UploadsChunkedApiCommitSessionRequest = {
    
    /**
    * The ID of the upload session.
    * @type {string}
    * @memberof UploadsChunkedApiCommitSession
    */
    readonly uploadSessionId: string
    
    /**
    * The [RFC3230][1] message digest of the whole file.  Only SHA1 is supported. The SHA1 digest must be Base64 encoded. The format of this header is as `sha=BASE64_ENCODED_DIGEST`.  [1]: https://tools.ietf.org/html/rfc3230
    * @type {string}
    * @memberof UploadsChunkedApiCommitSession
    */
    readonly digest: string
    
    /**
    * Ensures this item hasn\'t recently changed before making changes.  Pass in the item\'s last observed `etag` value into this header and the endpoint will fail with a `412 Precondition Failed` if it has changed since.
    * @type {string}
    * @memberof UploadsChunkedApiCommitSession
    */
    readonly ifMatch?: string
    
    /**
    * Ensures an item is only returned if it has changed.  Pass in the item\'s last observed `etag` value into this header and the endpoint will fail with a `304 Not Modified` if the item has not changed since.
    * @type {string}
    * @memberof UploadsChunkedApiCommitSession
    */
    readonly ifNoneMatch?: string
    
} & UploadsChunkedCommitSessionRequest

/**
 * Request parameters for createSessionForUpload operation in UploadsChunkedApi.
 * @export
 * @interface UploadsChunkedApiCreateSessionForUploadRequest
 */
export type UploadsChunkedApiCreateSessionForUploadRequest = {
    
} & UploadsChunkedCreateSessionForUploadRequest

/**
 * Request parameters for createSessionForUpload_1 operation in UploadsChunkedApi.
 * @export
 * @interface UploadsChunkedApiCreateSessionForUpload0Request
 */
export type UploadsChunkedApiCreateSessionForUpload0Request = {
    
    /**
    * The unique identifier that represents a file.  The ID for any file can be determined by visiting a file in the web application and copying the ID from the URL. For example, for the URL `https://_*.app.box.com/files/123` the `file_id` is `123`.
    * @type {string}
    * @memberof UploadsChunkedApiCreateSessionForUpload0
    */
    readonly fileId: string
    
} & UploadsChunkedCreateSessionForUploadRequest1

/**
 * Request parameters for filePartUpdate operation in UploadsChunkedApi.
 * @export
 * @interface UploadsChunkedApiFilePartUpdateRequest
 */
export type UploadsChunkedApiFilePartUpdateRequest = {
    /**
    * The ID of the upload session.
    * @type {string}
    * @memberof UploadsChunkedApiFilePartUpdate
    */
    readonly uploadSessionId: string
    /**
    * The [RFC3230][1] message digest of the chunk uploaded.  Only SHA1 is supported. The SHA1 digest must be base64 encoded. The format of this header is as `sha=BASE64_ENCODED_DIGEST`.  To get the value for the `SHA` digest, use the openSSL command to encode the file part: `openssl sha1 -binary <FILE_PART_NAME> | base64`  [1]: https://tools.ietf.org/html/rfc3230
    * @type {string}
    * @memberof UploadsChunkedApiFilePartUpdate
    */
    readonly digest: string
    /**
    * The byte range of the chunk.  Must not overlap with the range of a part already uploaded this session. Each part’s size must be exactly equal in size to the part size specified in the upload session that you created. One exception is the last part of the file, as this can be smaller.  When providing the value for `content-range`, remember that:  * The lower bound of each part\'s byte range   must be a multiple of the part size. * The higher bound must be a multiple of the part size - 1.
    * @type {string}
    * @memberof UploadsChunkedApiFilePartUpdate
    */
    readonly contentRange: string
    /**
    * 
    * @type {Uint8Array | File | buffer.File}
    * @memberof UploadsChunkedApiFilePartUpdate
    */
    readonly requestBody?: Uint8Array | File | buffer.File
}

/**
 * Request parameters for info operation in UploadsChunkedApi.
 * @export
 * @interface UploadsChunkedApiInfoRequest
 */
export type UploadsChunkedApiInfoRequest = {
    
    /**
    * The ID of the upload session.
    * @type {string}
    * @memberof UploadsChunkedApiInfo
    */
    readonly uploadSessionId: string
    
}

/**
 * Request parameters for listParts operation in UploadsChunkedApi.
 * @export
 * @interface UploadsChunkedApiListPartsRequest
 */
export type UploadsChunkedApiListPartsRequest = {
    
    /**
    * The ID of the upload session.
    * @type {string}
    * @memberof UploadsChunkedApiListParts
    */
    readonly uploadSessionId: string
    
    /**
    * The offset of the item at which to begin the response.  Queries with offset parameter value exceeding 10000 will be rejected with a 400 response.
    * @type {number}
    * @memberof UploadsChunkedApiListParts
    */
    readonly offset?: number
    
    /**
    * The maximum number of items to return per page.
    * @type {number}
    * @memberof UploadsChunkedApiListParts
    */
    readonly limit?: number
    
}

/**
 * Request parameters for removeUploadSession operation in UploadsChunkedApi.
 * @export
 * @interface UploadsChunkedApiRemoveUploadSessionRequest
 */
export type UploadsChunkedApiRemoveUploadSessionRequest = {
    
    /**
    * The ID of the upload session.
    * @type {string}
    * @memberof UploadsChunkedApiRemoveUploadSession
    */
    readonly uploadSessionId: string
    
}

/**
 * UploadsChunkedApiGenerated - object-oriented interface
 * @export
 * @class UploadsChunkedApiGenerated
 * @extends {BaseAPI}
 */
export class UploadsChunkedApiGenerated extends BaseAPI {
    /**
     * Close an upload session and create a file from the uploaded chunks.
     * @summary Commit upload session
     * @param {UploadsChunkedApiCommitSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsChunkedApiGenerated
     */
    public commitSession(requestParameters: UploadsChunkedApiCommitSessionRequest, options?: AxiosRequestConfig) {
        return UploadsChunkedApiFp(this.configuration).commitSession(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an upload session for a new file.
     * @summary Create upload session
     * @param {UploadsChunkedApiCreateSessionForUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsChunkedApiGenerated
     */
    public createSessionForUpload(requestParameters: UploadsChunkedApiCreateSessionForUploadRequest, options?: AxiosRequestConfig) {
        return UploadsChunkedApiFp(this.configuration).createSessionForUpload(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an upload session for an existing file.
     * @summary Create upload session for existing file
     * @param {UploadsChunkedApiCreateSessionForUpload0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsChunkedApiGenerated
     */
    public createSessionForUpload_1(requestParameters: UploadsChunkedApiCreateSessionForUpload0Request, options?: AxiosRequestConfig) {
        return UploadsChunkedApiFp(this.configuration).createSessionForUpload_1(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a chunk of an upload session for a file.
     * @summary Upload part of file
     * @param {UploadsChunkedApiFilePartUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsChunkedApiGenerated
     */
    public filePartUpdate(requestParameters: UploadsChunkedApiFilePartUpdateRequest, options?: AxiosRequestConfig) {
        return UploadsChunkedApiFp(this.configuration).filePartUpdate(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return information about an upload session.
     * @summary Get upload session
     * @param {UploadsChunkedApiInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsChunkedApiGenerated
     */
    public info(requestParameters: UploadsChunkedApiInfoRequest, options?: AxiosRequestConfig) {
        return UploadsChunkedApiFp(this.configuration).info(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of the chunks uploaded to the upload session so far.
     * @summary List parts
     * @param {UploadsChunkedApiListPartsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsChunkedApiGenerated
     */
    public listParts(requestParameters: UploadsChunkedApiListPartsRequest, options?: AxiosRequestConfig) {
        return UploadsChunkedApiFp(this.configuration).listParts(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Abort an upload session and discard all data uploaded.  This cannot be reversed.
     * @summary Remove upload session
     * @param {UploadsChunkedApiRemoveUploadSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsChunkedApiGenerated
     */
    public removeUploadSession(requestParameters: UploadsChunkedApiRemoveUploadSessionRequest, options?: AxiosRequestConfig) {
        return UploadsChunkedApiFp(this.configuration).removeUploadSession(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
