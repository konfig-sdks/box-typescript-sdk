/* tslint:disable */
/* eslint-disable */
/*
Box Platform API

[Box Platform](https://box.dev) provides functionality to provide access to content stored within [Box](https://box.com). It provides endpoints for basic manipulation of files and folders, management of users within an enterprise, as well as more complex topics such as legal holds and retention policies.

The version of the OpenAPI document: 2.0.0
Contact: devrel@box.com

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AccessToken } from '../models';
// @ts-ignore
import { OAuth2Error } from '../models';
// @ts-ignore
import { PostOAuth2Revoke } from '../models';
// @ts-ignore
import { PostOAuth2Token } from '../models';
// @ts-ignore
import { PostOAuth2TokenRefreshAccessToken } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * AuthorizationApi - axios parameter creator
 * @export
 */
export const AuthorizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authorize a user by sending them through the [Box](https://box.com) website and request their permission to act on their behalf.  This is the first step when authenticating a user using OAuth 2.0. To request a user\'s authorization to use the Box APIs on their behalf you will need to send a user to the URL with this format.
         * @summary Authorize user
         * @param {'code'} responseType The type of response we\&#39;d like to receive.
         * @param {string} clientId The Client ID of the application that is requesting to authenticate the user. To get the Client ID for your application, log in to your Box developer console and click the **Edit Application** link for the application you\&#39;re working with. In the OAuth 2.0 Parameters section of the configuration page, find the item labelled &#x60;client_id&#x60;. The text of that item is your application\&#39;s Client ID.
         * @param {string} [redirectUri] The URI to which Box redirects the browser after the user has granted or denied the application permission. This URI match one of the redirect URIs in the configuration of your application. It must be a valid HTTPS URI and it needs to be able to handle the redirection to complete the next step in the OAuth 2.0 flow. Although this parameter is optional, it must be a part of the authorization URL if you configured multiple redirect URIs for the application in the developer console. A missing parameter causes a &#x60;redirect_uri_missing&#x60; error after the user grants application access.
         * @param {string} [state] A custom string of your choice. Box will pass the same string to the redirect URL when authentication is complete. This parameter can be used to identify a user on redirect, as well as protect against hijacked sessions and other exploits.
         * @param {string} [scope] A space-separated list of application scopes you\&#39;d like to authenticate the user for. This defaults to all the scopes configured for the application in its configuration page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize: async (responseType: 'code', clientId: string, redirectUri?: string, state?: string, scope?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'responseType' is not null or undefined
            assertParamExists('authorize', 'responseType', responseType)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('authorize', 'clientId', clientId)
            const localVarPath = `/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            if (responseType !== undefined) {
                localVarQueryParameter['response_type'] = responseType;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/authorize',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh an Access Token using its client ID, secret, and refresh token.
         * @summary Refresh access token
         * @param {string} grantType The type of request being made, in this case a refresh request.
         * @param {string} clientId The client ID of the application requesting to refresh the token.
         * @param {string} clientSecret The client secret of the application requesting to refresh the token.
         * @param {string} refreshToken The refresh token to refresh.
         * @param {PostOAuth2TokenRefreshAccessToken} [postOAuth2TokenRefreshAccessToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken: async (grantType: string, clientId: string, clientSecret: string, refreshToken: string, postOAuth2TokenRefreshAccessToken?: PostOAuth2TokenRefreshAccessToken, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'grantType' is not null or undefined
            assertParamExists('refreshAccessToken', 'grantType', grantType)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('refreshAccessToken', 'clientId', clientId)
            // verify required parameter 'clientSecret' is not null or undefined
            assertParamExists('refreshAccessToken', 'clientSecret', clientSecret)
            // verify required parameter 'refreshToken' is not null or undefined
            assertParamExists('refreshAccessToken', 'refreshToken', refreshToken)
            const localVarPath = `/oauth2/token#refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;


            if (grantType !== undefined) {
                await addFormParam('grant_type', grantType, false, true)
            }
    
            if (clientId !== undefined) {
                await addFormParam('client_id', clientId, false, true)
            }
    
            if (clientSecret !== undefined) {
                await addFormParam('client_secret', clientSecret, false, true)
            }
    
            if (refreshToken !== undefined) {
                await addFormParam('refresh_token', refreshToken, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: postOAuth2TokenRefreshAccessToken,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/oauth2/token#refresh',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(postOAuth2TokenRefreshAccessToken, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request an Access Token using either a client-side obtained OAuth 2.0 authorization code or a server-side JWT assertion.  An Access Token is a string that enables Box to verify that a request belongs to an authorized session. In the normal order of operations you will begin by requesting authentication from the [authorize](https://raw.githubusercontent.com) endpoint and Box will send you an authorization code.  You will then send this code to this endpoint to exchange it for an Access Token. The returned Access Token can then be used to to make Box API calls.
         * @summary Request access token
         * @param {string} grantType The type of request being made, either using a client-side obtained authorization code, a refresh token, a JWT assertion, client credentials grant or another access token for the purpose of downscoping a token.
         * @param {string} [clientId] The Client ID of the application requesting an access token.  Used in combination with &#x60;authorization_code&#x60;, &#x60;client_credentials&#x60;, or &#x60;urn:ietf:params:oauth:grant-type:jwt-bearer&#x60; as the &#x60;grant_type&#x60;.
         * @param {string} [clientSecret] The client secret of the application requesting an access token.  Used in combination with &#x60;authorization_code&#x60;, &#x60;client_credentials&#x60;, or &#x60;urn:ietf:params:oauth:grant-type:jwt-bearer&#x60; as the &#x60;grant_type&#x60;.
         * @param {string} [code] The client-side authorization code passed to your application by Box in the browser redirect after the user has successfully granted your application permission to make API calls on their behalf.  Used in combination with &#x60;authorization_code&#x60; as the &#x60;grant_type&#x60;.
         * @param {string} [refreshToken] A refresh token used to get a new access token with.  Used in combination with &#x60;refresh_token&#x60; as the &#x60;grant_type&#x60;.
         * @param {string} [assertion] A JWT assertion for which to request a new access token.  Used in combination with &#x60;urn:ietf:params:oauth:grant-type:jwt-bearer&#x60; as the &#x60;grant_type&#x60;.
         * @param {string} [subjectToken] The token to exchange for a downscoped token. This can be a regular access token, a JWT assertion, or an app token.  Used in combination with &#x60;urn:ietf:params:oauth:grant-type:token-exchange&#x60; as the &#x60;grant_type&#x60;.
         * @param {string} [subjectTokenType] The type of &#x60;subject_token&#x60; passed in.  Used in combination with &#x60;urn:ietf:params:oauth:grant-type:token-exchange&#x60; as the &#x60;grant_type&#x60;.
         * @param {string} [actorToken] The token used to create an annotator token. This is a JWT assertion.  Used in combination with &#x60;urn:ietf:params:oauth:grant-type:token-exchange&#x60; as the &#x60;grant_type&#x60;.
         * @param {string} [actorTokenType] The type of &#x60;actor_token&#x60; passed in.  Used in combination with &#x60;urn:ietf:params:oauth:grant-type:token-exchange&#x60; as the &#x60;grant_type&#x60;.
         * @param {string} [scope] The space-delimited list of scopes that you want apply to the new access token.  The &#x60;subject_token&#x60; will need to have all of these scopes or the call will error with **401 Unauthorized**.
         * @param {string} [resource] Full URL for the file that the token should be generated for.
         * @param {string} [boxSubjectType] Used in combination with &#x60;client_credentials&#x60; as the &#x60;grant_type&#x60;.
         * @param {string} [boxSubjectId] Used in combination with &#x60;client_credentials&#x60; as the &#x60;grant_type&#x60;. Value is determined by &#x60;box_subject_type&#x60;. If &#x60;user&#x60; use user ID and if &#x60;enterprise&#x60; use enterprise ID.
         * @param {string} [boxSharedLink] Full URL of the shared link on the file or folder that the token should be generated for.
         * @param {PostOAuth2Token} [postOAuth2Token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAccessToken: async (grantType: string, clientId?: string, clientSecret?: string, code?: string, refreshToken?: string, assertion?: string, subjectToken?: string, subjectTokenType?: string, actorToken?: string, actorTokenType?: string, scope?: string, resource?: string, boxSubjectType?: string, boxSubjectId?: string, boxSharedLink?: string, postOAuth2Token?: PostOAuth2Token, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'grantType' is not null or undefined
            assertParamExists('requestAccessToken', 'grantType', grantType)
            const localVarPath = `/oauth2/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;


            if (grantType !== undefined) {
                await addFormParam('grant_type', grantType, false, true)
            }
    
            if (clientId !== undefined) {
                await addFormParam('client_id', clientId, false, true)
            }
    
            if (clientSecret !== undefined) {
                await addFormParam('client_secret', clientSecret, false, true)
            }
    
            if (code !== undefined) {
                await addFormParam('code', code, false, true)
            }
    
            if (refreshToken !== undefined) {
                await addFormParam('refresh_token', refreshToken, false, true)
            }
    
            if (assertion !== undefined) {
                await addFormParam('assertion', assertion, false, true)
            }
    
            if (subjectToken !== undefined) {
                await addFormParam('subject_token', subjectToken, false, true)
            }
    
            if (subjectTokenType !== undefined) {
                await addFormParam('subject_token_type', subjectTokenType, false, true)
            }
    
            if (actorToken !== undefined) {
                await addFormParam('actor_token', actorToken, false, true)
            }
    
            if (actorTokenType !== undefined) {
                await addFormParam('actor_token_type', actorTokenType, false, true)
            }
    
            if (scope !== undefined) {
                await addFormParam('scope', scope, false, true)
            }
    
            if (resource !== undefined) {
                await addFormParam('resource', resource, false, true)
            }
    
            if (boxSubjectType !== undefined) {
                await addFormParam('box_subject_type', boxSubjectType, false, true)
            }
    
            if (boxSubjectId !== undefined) {
                await addFormParam('box_subject_id', boxSubjectId, false, true)
            }
    
            if (boxSharedLink !== undefined) {
                await addFormParam('box_shared_link', boxSharedLink, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: postOAuth2Token,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/oauth2/token',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(postOAuth2Token, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke an active Access Token, effectively logging a user out that has been previously authenticated.
         * @summary Revoke access token
         * @param {string} [clientId] The Client ID of the application requesting to revoke the access token.
         * @param {string} [clientSecret] The client secret of the application requesting to revoke an access token.
         * @param {string} [token] The access token to revoke.
         * @param {PostOAuth2Revoke} [postOAuth2Revoke] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeAccessToken: async (clientId?: string, clientSecret?: string, token?: string, postOAuth2Revoke?: PostOAuth2Revoke, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth2/revoke`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;


            if (clientId !== undefined) {
                await addFormParam('client_id', clientId, false, true)
            }
    
            if (clientSecret !== undefined) {
                await addFormParam('client_secret', clientSecret, false, true)
            }
    
            if (token !== undefined) {
                await addFormParam('token', token, false, true)
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: postOAuth2Revoke,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/oauth2/revoke',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(postOAuth2Revoke, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorizationApi - functional programming interface
 * @export
 */
export const AuthorizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthorizationApiAxiosParamCreator(configuration)
    return {
        /**
         * Authorize a user by sending them through the [Box](https://box.com) website and request their permission to act on their behalf.  This is the first step when authenticating a user using OAuth 2.0. To request a user\'s authorization to use the Box APIs on their behalf you will need to send a user to the URL with this format.
         * @summary Authorize user
         * @param {AuthorizationApiAuthorizeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorize(requestParameters: AuthorizationApiAuthorizeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorize(requestParameters.responseType, requestParameters.clientId, requestParameters.redirectUri, requestParameters.state, requestParameters.scope, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh an Access Token using its client ID, secret, and refresh token.
         * @summary Refresh access token
         * @param {AuthorizationApiRefreshAccessTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshAccessToken(requestParameters: AuthorizationApiRefreshAccessTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const postOAuth2TokenRefreshAccessToken: PostOAuth2TokenRefreshAccessToken = {
                grant_type: requestParameters.grant_type,
                client_id: requestParameters.client_id,
                client_secret: requestParameters.client_secret,
                refresh_token: requestParameters.refresh_token
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshAccessToken(requestParameters.grantType, requestParameters.clientId, requestParameters.clientSecret, requestParameters.refreshToken, postOAuth2TokenRefreshAccessToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Request an Access Token using either a client-side obtained OAuth 2.0 authorization code or a server-side JWT assertion.  An Access Token is a string that enables Box to verify that a request belongs to an authorized session. In the normal order of operations you will begin by requesting authentication from the [authorize](https://raw.githubusercontent.com) endpoint and Box will send you an authorization code.  You will then send this code to this endpoint to exchange it for an Access Token. The returned Access Token can then be used to to make Box API calls.
         * @summary Request access token
         * @param {AuthorizationApiRequestAccessTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestAccessToken(requestParameters: AuthorizationApiRequestAccessTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const postOAuth2Token: PostOAuth2Token = {
                grant_type: requestParameters.grant_type,
                client_id: requestParameters.client_id,
                client_secret: requestParameters.client_secret,
                code: requestParameters.code,
                refresh_token: requestParameters.refresh_token,
                assertion: requestParameters.assertion,
                subject_token: requestParameters.subject_token,
                subject_token_type: requestParameters.subject_token_type,
                actor_token: requestParameters.actor_token,
                actor_token_type: requestParameters.actor_token_type,
                scope: requestParameters.scope,
                resource: requestParameters.resource,
                box_subject_type: requestParameters.box_subject_type,
                box_subject_id: requestParameters.box_subject_id,
                box_shared_link: requestParameters.box_shared_link
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestAccessToken(requestParameters.grantType, requestParameters.clientId, requestParameters.clientSecret, requestParameters.code, requestParameters.refreshToken, requestParameters.assertion, requestParameters.subjectToken, requestParameters.subjectTokenType, requestParameters.actorToken, requestParameters.actorTokenType, requestParameters.scope, requestParameters.resource, requestParameters.boxSubjectType, requestParameters.boxSubjectId, requestParameters.boxSharedLink, postOAuth2Token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Revoke an active Access Token, effectively logging a user out that has been previously authenticated.
         * @summary Revoke access token
         * @param {AuthorizationApiRevokeAccessTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeAccessToken(requestParameters: AuthorizationApiRevokeAccessTokenRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const postOAuth2Revoke: PostOAuth2Revoke = {
                client_id: requestParameters.client_id,
                client_secret: requestParameters.client_secret,
                token: requestParameters.token
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeAccessToken(requestParameters.clientId, requestParameters.clientSecret, requestParameters.token, postOAuth2Revoke, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthorizationApi - factory interface
 * @export
 */
export const AuthorizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthorizationApiFp(configuration)
    return {
        /**
         * Authorize a user by sending them through the [Box](https://box.com) website and request their permission to act on their behalf.  This is the first step when authenticating a user using OAuth 2.0. To request a user\'s authorization to use the Box APIs on their behalf you will need to send a user to the URL with this format.
         * @summary Authorize user
         * @param {AuthorizationApiAuthorizeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize(requestParameters: AuthorizationApiAuthorizeRequest, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.authorize(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh an Access Token using its client ID, secret, and refresh token.
         * @summary Refresh access token
         * @param {AuthorizationApiRefreshAccessTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken(requestParameters: AuthorizationApiRefreshAccessTokenRequest, options?: AxiosRequestConfig): AxiosPromise<AccessToken> {
            return localVarFp.refreshAccessToken(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Request an Access Token using either a client-side obtained OAuth 2.0 authorization code or a server-side JWT assertion.  An Access Token is a string that enables Box to verify that a request belongs to an authorized session. In the normal order of operations you will begin by requesting authentication from the [authorize](https://raw.githubusercontent.com) endpoint and Box will send you an authorization code.  You will then send this code to this endpoint to exchange it for an Access Token. The returned Access Token can then be used to to make Box API calls.
         * @summary Request access token
         * @param {AuthorizationApiRequestAccessTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAccessToken(requestParameters: AuthorizationApiRequestAccessTokenRequest, options?: AxiosRequestConfig): AxiosPromise<AccessToken> {
            return localVarFp.requestAccessToken(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke an active Access Token, effectively logging a user out that has been previously authenticated.
         * @summary Revoke access token
         * @param {AuthorizationApiRevokeAccessTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeAccessToken(requestParameters: AuthorizationApiRevokeAccessTokenRequest = {}, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.revokeAccessToken(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authorize operation in AuthorizationApi.
 * @export
 * @interface AuthorizationApiAuthorizeRequest
 */
export type AuthorizationApiAuthorizeRequest = {
    
    /**
    * The type of response we\'d like to receive.
    * @type {'code'}
    * @memberof AuthorizationApiAuthorize
    */
    readonly responseType: 'code'
    
    /**
    * The Client ID of the application that is requesting to authenticate the user. To get the Client ID for your application, log in to your Box developer console and click the **Edit Application** link for the application you\'re working with. In the OAuth 2.0 Parameters section of the configuration page, find the item labelled `client_id`. The text of that item is your application\'s Client ID.
    * @type {string}
    * @memberof AuthorizationApiAuthorize
    */
    readonly clientId: string
    
    /**
    * The URI to which Box redirects the browser after the user has granted or denied the application permission. This URI match one of the redirect URIs in the configuration of your application. It must be a valid HTTPS URI and it needs to be able to handle the redirection to complete the next step in the OAuth 2.0 flow. Although this parameter is optional, it must be a part of the authorization URL if you configured multiple redirect URIs for the application in the developer console. A missing parameter causes a `redirect_uri_missing` error after the user grants application access.
    * @type {string}
    * @memberof AuthorizationApiAuthorize
    */
    readonly redirectUri?: string
    
    /**
    * A custom string of your choice. Box will pass the same string to the redirect URL when authentication is complete. This parameter can be used to identify a user on redirect, as well as protect against hijacked sessions and other exploits.
    * @type {string}
    * @memberof AuthorizationApiAuthorize
    */
    readonly state?: string
    
    /**
    * A space-separated list of application scopes you\'d like to authenticate the user for. This defaults to all the scopes configured for the application in its configuration page.
    * @type {string}
    * @memberof AuthorizationApiAuthorize
    */
    readonly scope?: string
    
}

/**
 * Request parameters for refreshAccessToken operation in AuthorizationApi.
 * @export
 * @interface AuthorizationApiRefreshAccessTokenRequest
 */
export type AuthorizationApiRefreshAccessTokenRequest = {
    
    /**
    * The type of request being made, in this case a refresh request.
    * @type {string}
    * @memberof AuthorizationApiRefreshAccessToken
    */
    readonly grantType: string
    
    /**
    * The client ID of the application requesting to refresh the token.
    * @type {string}
    * @memberof AuthorizationApiRefreshAccessToken
    */
    readonly clientId: string
    
    /**
    * The client secret of the application requesting to refresh the token.
    * @type {string}
    * @memberof AuthorizationApiRefreshAccessToken
    */
    readonly clientSecret: string
    
    /**
    * The refresh token to refresh.
    * @type {string}
    * @memberof AuthorizationApiRefreshAccessToken
    */
    readonly refreshToken: string
    
} & PostOAuth2TokenRefreshAccessToken

/**
 * Request parameters for requestAccessToken operation in AuthorizationApi.
 * @export
 * @interface AuthorizationApiRequestAccessTokenRequest
 */
export type AuthorizationApiRequestAccessTokenRequest = {
    
    /**
    * The type of request being made, either using a client-side obtained authorization code, a refresh token, a JWT assertion, client credentials grant or another access token for the purpose of downscoping a token.
    * @type {string}
    * @memberof AuthorizationApiRequestAccessToken
    */
    readonly grantType: string
    
    /**
    * The Client ID of the application requesting an access token.  Used in combination with `authorization_code`, `client_credentials`, or `urn:ietf:params:oauth:grant-type:jwt-bearer` as the `grant_type`.
    * @type {string}
    * @memberof AuthorizationApiRequestAccessToken
    */
    readonly clientId?: string
    
    /**
    * The client secret of the application requesting an access token.  Used in combination with `authorization_code`, `client_credentials`, or `urn:ietf:params:oauth:grant-type:jwt-bearer` as the `grant_type`.
    * @type {string}
    * @memberof AuthorizationApiRequestAccessToken
    */
    readonly clientSecret?: string
    
    /**
    * The client-side authorization code passed to your application by Box in the browser redirect after the user has successfully granted your application permission to make API calls on their behalf.  Used in combination with `authorization_code` as the `grant_type`.
    * @type {string}
    * @memberof AuthorizationApiRequestAccessToken
    */
    readonly code?: string
    
    /**
    * A refresh token used to get a new access token with.  Used in combination with `refresh_token` as the `grant_type`.
    * @type {string}
    * @memberof AuthorizationApiRequestAccessToken
    */
    readonly refreshToken?: string
    
    /**
    * A JWT assertion for which to request a new access token.  Used in combination with `urn:ietf:params:oauth:grant-type:jwt-bearer` as the `grant_type`.
    * @type {string}
    * @memberof AuthorizationApiRequestAccessToken
    */
    readonly assertion?: string
    
    /**
    * The token to exchange for a downscoped token. This can be a regular access token, a JWT assertion, or an app token.  Used in combination with `urn:ietf:params:oauth:grant-type:token-exchange` as the `grant_type`.
    * @type {string}
    * @memberof AuthorizationApiRequestAccessToken
    */
    readonly subjectToken?: string
    
    /**
    * The type of `subject_token` passed in.  Used in combination with `urn:ietf:params:oauth:grant-type:token-exchange` as the `grant_type`.
    * @type {string}
    * @memberof AuthorizationApiRequestAccessToken
    */
    readonly subjectTokenType?: string
    
    /**
    * The token used to create an annotator token. This is a JWT assertion.  Used in combination with `urn:ietf:params:oauth:grant-type:token-exchange` as the `grant_type`.
    * @type {string}
    * @memberof AuthorizationApiRequestAccessToken
    */
    readonly actorToken?: string
    
    /**
    * The type of `actor_token` passed in.  Used in combination with `urn:ietf:params:oauth:grant-type:token-exchange` as the `grant_type`.
    * @type {string}
    * @memberof AuthorizationApiRequestAccessToken
    */
    readonly actorTokenType?: string
    
    /**
    * The space-delimited list of scopes that you want apply to the new access token.  The `subject_token` will need to have all of these scopes or the call will error with **401 Unauthorized**.
    * @type {string}
    * @memberof AuthorizationApiRequestAccessToken
    */
    readonly scope?: string
    
    /**
    * Full URL for the file that the token should be generated for.
    * @type {string}
    * @memberof AuthorizationApiRequestAccessToken
    */
    readonly resource?: string
    
    /**
    * Used in combination with `client_credentials` as the `grant_type`.
    * @type {string}
    * @memberof AuthorizationApiRequestAccessToken
    */
    readonly boxSubjectType?: string
    
    /**
    * Used in combination with `client_credentials` as the `grant_type`. Value is determined by `box_subject_type`. If `user` use user ID and if `enterprise` use enterprise ID.
    * @type {string}
    * @memberof AuthorizationApiRequestAccessToken
    */
    readonly boxSubjectId?: string
    
    /**
    * Full URL of the shared link on the file or folder that the token should be generated for.
    * @type {string}
    * @memberof AuthorizationApiRequestAccessToken
    */
    readonly boxSharedLink?: string
    
} & PostOAuth2Token

/**
 * Request parameters for revokeAccessToken operation in AuthorizationApi.
 * @export
 * @interface AuthorizationApiRevokeAccessTokenRequest
 */
export type AuthorizationApiRevokeAccessTokenRequest = {
    
    /**
    * The Client ID of the application requesting to revoke the access token.
    * @type {string}
    * @memberof AuthorizationApiRevokeAccessToken
    */
    readonly clientId?: string
    
    /**
    * The client secret of the application requesting to revoke an access token.
    * @type {string}
    * @memberof AuthorizationApiRevokeAccessToken
    */
    readonly clientSecret?: string
    
    /**
    * The access token to revoke.
    * @type {string}
    * @memberof AuthorizationApiRevokeAccessToken
    */
    readonly token?: string
    
} & PostOAuth2Revoke

/**
 * AuthorizationApiGenerated - object-oriented interface
 * @export
 * @class AuthorizationApiGenerated
 * @extends {BaseAPI}
 */
export class AuthorizationApiGenerated extends BaseAPI {
    /**
     * Authorize a user by sending them through the [Box](https://box.com) website and request their permission to act on their behalf.  This is the first step when authenticating a user using OAuth 2.0. To request a user\'s authorization to use the Box APIs on their behalf you will need to send a user to the URL with this format.
     * @summary Authorize user
     * @param {AuthorizationApiAuthorizeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApiGenerated
     */
    public authorize(requestParameters: AuthorizationApiAuthorizeRequest, options?: AxiosRequestConfig) {
        return AuthorizationApiFp(this.configuration).authorize(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh an Access Token using its client ID, secret, and refresh token.
     * @summary Refresh access token
     * @param {AuthorizationApiRefreshAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApiGenerated
     */
    public refreshAccessToken(requestParameters: AuthorizationApiRefreshAccessTokenRequest, options?: AxiosRequestConfig) {
        return AuthorizationApiFp(this.configuration).refreshAccessToken(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request an Access Token using either a client-side obtained OAuth 2.0 authorization code or a server-side JWT assertion.  An Access Token is a string that enables Box to verify that a request belongs to an authorized session. In the normal order of operations you will begin by requesting authentication from the [authorize](https://raw.githubusercontent.com) endpoint and Box will send you an authorization code.  You will then send this code to this endpoint to exchange it for an Access Token. The returned Access Token can then be used to to make Box API calls.
     * @summary Request access token
     * @param {AuthorizationApiRequestAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApiGenerated
     */
    public requestAccessToken(requestParameters: AuthorizationApiRequestAccessTokenRequest, options?: AxiosRequestConfig) {
        return AuthorizationApiFp(this.configuration).requestAccessToken(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke an active Access Token, effectively logging a user out that has been previously authenticated.
     * @summary Revoke access token
     * @param {AuthorizationApiRevokeAccessTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApiGenerated
     */
    public revokeAccessToken(requestParameters: AuthorizationApiRevokeAccessTokenRequest = {}, options?: AxiosRequestConfig) {
        return AuthorizationApiFp(this.configuration).revokeAccessToken(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
