/* tslint:disable */
/* eslint-disable */
/*
Box Platform API

[Box Platform](https://box.dev) provides functionality to provide access to content stored within [Box](https://box.com). It provides endpoints for basic manipulation of files and folders, management of users within an enterprise, as well as more complex topics such as legal holds and retention policies.

The version of the OpenAPI document: 2.0.0
Contact: devrel@box.com

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ClientError } from '../models';
// @ts-ignore
import { Files } from '../models';
// @ts-ignore
import { UploadsFileContentUpdateRequest } from '../models';
// @ts-ignore
import { UploadsFileContentUpdateRequestAttributes } from '../models';
// @ts-ignore
import { UploadsSmallFileRequest } from '../models';
// @ts-ignore
import { UploadsSmallFileRequestAttributes } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * UploadsApi - axios parameter creator
 * @export
 */
export const UploadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update a file\'s content. For file sizes over 50MB we recommend using the Chunk Upload APIs.  # Request body order  The `attributes` part of the body must come **before** the `file` part. Requests that do not follow this format when uploading the file will receive a HTTP `400` error with a `metadata_after_file_contents` error code.
         * @summary Upload file version
         * @param {string} fileId The unique identifier that represents a file.  The ID for any file can be determined by visiting a file in the web application and copying the ID from the URL. For example, for the URL &#x60;https://_*.app.box.com/files/123&#x60; the &#x60;file_id&#x60; is &#x60;123&#x60;.
         * @param {UploadsFileContentUpdateRequestAttributes} attributes 
         * @param {Uint8Array | File | buffer.File} file The content of the file to upload to Box.  &lt;Message warning&gt;    The &#x60;attributes&#x60; part of the body must come **before** the   &#x60;file&#x60; part. Requests that do not follow this format when   uploading the file will receive a HTTP &#x60;400&#x60; error with a   &#x60;metadata_after_file_contents&#x60; error code.  &lt;/Message&gt;
         * @param {string} [ifMatch] Ensures this item hasn\&#39;t recently changed before making changes.  Pass in the item\&#39;s last observed &#x60;etag&#x60; value into this header and the endpoint will fail with a &#x60;412 Precondition Failed&#x60; if it has changed since.
         * @param {Array<string>} [fields] A comma-separated list of attributes to include in the response. This can be used to request fields that are not normally returned in a standard response.  Be aware that specifying this parameter will have the effect that none of the standard fields are returned in the response unless explicitly specified, instead only fields for the mini representation are returned, additional to the fields requested.
         * @param {string} [contentMd5] An optional header containing the SHA1 hash of the file to ensure that the file was not corrupted in transit.
         * @param {UploadsFileContentUpdateRequest} [uploadsFileContentUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileContentUpdate: async (fileId: string, attributes: UploadsFileContentUpdateRequestAttributes, file: Uint8Array | File | buffer.File, ifMatch?: string, fields?: Array<string>, contentMd5?: string, uploadsFileContentUpdateRequest?: UploadsFileContentUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('fileContentUpdate', 'fileId', fileId)
            // verify required parameter 'attributes' is not null or undefined
            assertParamExists('fileContentUpdate', 'attributes', attributes)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('fileContentUpdate', 'file', file)
            const localVarPath = `/files/{file_id}/content`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId !== undefined ? fileId : `-file_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (ifMatch != null) {
                localVarHeaderParameter['if-match'] = String(ifMatch);
            }

            if (contentMd5 != null) {
                localVarHeaderParameter['content-md5'] = String(contentMd5);
            }


            if (attributes !== undefined) {
                await addFormParam('attributes', attributes, false, false)
            }
    
            if (file !== undefined) {
                await addFormParam('file', file, true, true)
            }
    
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: uploadsFileContentUpdateRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files/{file_id}/content',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a small file to Box. For file sizes over 50MB we recommend using the Chunk Upload APIs.  # Request body order  The `attributes` part of the body must come **before** the `file` part. Requests that do not follow this format when uploading the file will receive a HTTP `400` error with a `metadata_after_file_contents` error code.
         * @summary Upload file
         * @param {UploadsSmallFileRequestAttributes} attributes 
         * @param {Uint8Array | File | buffer.File} file The content of the file to upload to Box.  &lt;Message warning&gt;    The &#x60;attributes&#x60; part of the body must come **before** the   &#x60;file&#x60; part. Requests that do not follow this format when   uploading the file will receive a HTTP &#x60;400&#x60; error with a   &#x60;metadata_after_file_contents&#x60; error code.  &lt;/Message&gt;
         * @param {Array<string>} [fields] A comma-separated list of attributes to include in the response. This can be used to request fields that are not normally returned in a standard response.  Be aware that specifying this parameter will have the effect that none of the standard fields are returned in the response unless explicitly specified, instead only fields for the mini representation are returned, additional to the fields requested.
         * @param {string} [contentMd5] An optional header containing the SHA1 hash of the file to ensure that the file was not corrupted in transit.
         * @param {UploadsSmallFileRequest} [uploadsSmallFileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smallFile: async (attributes: UploadsSmallFileRequestAttributes, file: Uint8Array | File | buffer.File, fields?: Array<string>, contentMd5?: string, uploadsSmallFileRequest?: UploadsSmallFileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributes' is not null or undefined
            assertParamExists('smallFile', 'attributes', attributes)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('smallFile', 'file', file)
            const localVarPath = `/files/content`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)
            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (contentMd5 != null) {
                localVarHeaderParameter['content-md5'] = String(contentMd5);
            }


            if (attributes !== undefined) {
                await addFormParam('attributes', attributes, false, false)
            }
    
            if (file !== undefined) {
                await addFormParam('file', file, true, true)
            }
    
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: uploadsSmallFileRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/files/content',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadsApi - functional programming interface
 * @export
 */
export const UploadsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadsApiAxiosParamCreator(configuration)
    return {
        /**
         * Update a file\'s content. For file sizes over 50MB we recommend using the Chunk Upload APIs.  # Request body order  The `attributes` part of the body must come **before** the `file` part. Requests that do not follow this format when uploading the file will receive a HTTP `400` error with a `metadata_after_file_contents` error code.
         * @summary Upload file version
         * @param {UploadsApiFileContentUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileContentUpdate(requestParameters: UploadsApiFileContentUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Files>> {
            const uploadsFileContentUpdateRequest: UploadsFileContentUpdateRequest = {
                attributes: requestParameters.attributes,
                file: requestParameters.file
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileContentUpdate(requestParameters.fileId, requestParameters.attributes, requestParameters.file, requestParameters.ifMatch, requestParameters.fields, requestParameters.contentMd5, uploadsFileContentUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Uploads a small file to Box. For file sizes over 50MB we recommend using the Chunk Upload APIs.  # Request body order  The `attributes` part of the body must come **before** the `file` part. Requests that do not follow this format when uploading the file will receive a HTTP `400` error with a `metadata_after_file_contents` error code.
         * @summary Upload file
         * @param {UploadsApiSmallFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smallFile(requestParameters: UploadsApiSmallFileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Files>> {
            const uploadsSmallFileRequest: UploadsSmallFileRequest = {
                attributes: requestParameters.attributes,
                file: requestParameters.file
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.smallFile(requestParameters.attributes, requestParameters.file, requestParameters.fields, requestParameters.contentMd5, uploadsSmallFileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UploadsApi - factory interface
 * @export
 */
export const UploadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadsApiFp(configuration)
    return {
        /**
         * Update a file\'s content. For file sizes over 50MB we recommend using the Chunk Upload APIs.  # Request body order  The `attributes` part of the body must come **before** the `file` part. Requests that do not follow this format when uploading the file will receive a HTTP `400` error with a `metadata_after_file_contents` error code.
         * @summary Upload file version
         * @param {UploadsApiFileContentUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileContentUpdate(requestParameters: UploadsApiFileContentUpdateRequest, options?: AxiosRequestConfig): AxiosPromise<Files> {
            return localVarFp.fileContentUpdate(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a small file to Box. For file sizes over 50MB we recommend using the Chunk Upload APIs.  # Request body order  The `attributes` part of the body must come **before** the `file` part. Requests that do not follow this format when uploading the file will receive a HTTP `400` error with a `metadata_after_file_contents` error code.
         * @summary Upload file
         * @param {UploadsApiSmallFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smallFile(requestParameters: UploadsApiSmallFileRequest, options?: AxiosRequestConfig): AxiosPromise<Files> {
            return localVarFp.smallFile(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for fileContentUpdate operation in UploadsApi.
 * @export
 * @interface UploadsApiFileContentUpdateRequest
 */
export type UploadsApiFileContentUpdateRequest = {
    
    /**
    * The unique identifier that represents a file.  The ID for any file can be determined by visiting a file in the web application and copying the ID from the URL. For example, for the URL `https://_*.app.box.com/files/123` the `file_id` is `123`.
    * @type {string}
    * @memberof UploadsApiFileContentUpdate
    */
    readonly fileId: string
    
    /**
    * 
    * @type {UploadsFileContentUpdateRequestAttributes}
    * @memberof UploadsApiFileContentUpdate
    */
    readonly attributes: UploadsFileContentUpdateRequestAttributes
    
    /**
    * The content of the file to upload to Box.  <Message warning>    The `attributes` part of the body must come **before** the   `file` part. Requests that do not follow this format when   uploading the file will receive a HTTP `400` error with a   `metadata_after_file_contents` error code.  </Message>
    * @type {Uint8Array | File | buffer.File}
    * @memberof UploadsApiFileContentUpdate
    */
    readonly file: Uint8Array | File | buffer.File
    
    /**
    * Ensures this item hasn\'t recently changed before making changes.  Pass in the item\'s last observed `etag` value into this header and the endpoint will fail with a `412 Precondition Failed` if it has changed since.
    * @type {string}
    * @memberof UploadsApiFileContentUpdate
    */
    readonly ifMatch?: string
    
    /**
    * A comma-separated list of attributes to include in the response. This can be used to request fields that are not normally returned in a standard response.  Be aware that specifying this parameter will have the effect that none of the standard fields are returned in the response unless explicitly specified, instead only fields for the mini representation are returned, additional to the fields requested.
    * @type {Array<string>}
    * @memberof UploadsApiFileContentUpdate
    */
    readonly fields?: Array<string>
    
    /**
    * An optional header containing the SHA1 hash of the file to ensure that the file was not corrupted in transit.
    * @type {string}
    * @memberof UploadsApiFileContentUpdate
    */
    readonly contentMd5?: string
    
} & UploadsFileContentUpdateRequest

/**
 * Request parameters for smallFile operation in UploadsApi.
 * @export
 * @interface UploadsApiSmallFileRequest
 */
export type UploadsApiSmallFileRequest = {
    
    /**
    * 
    * @type {UploadsSmallFileRequestAttributes}
    * @memberof UploadsApiSmallFile
    */
    readonly attributes: UploadsSmallFileRequestAttributes
    
    /**
    * The content of the file to upload to Box.  <Message warning>    The `attributes` part of the body must come **before** the   `file` part. Requests that do not follow this format when   uploading the file will receive a HTTP `400` error with a   `metadata_after_file_contents` error code.  </Message>
    * @type {Uint8Array | File | buffer.File}
    * @memberof UploadsApiSmallFile
    */
    readonly file: Uint8Array | File | buffer.File
    
    /**
    * A comma-separated list of attributes to include in the response. This can be used to request fields that are not normally returned in a standard response.  Be aware that specifying this parameter will have the effect that none of the standard fields are returned in the response unless explicitly specified, instead only fields for the mini representation are returned, additional to the fields requested.
    * @type {Array<string>}
    * @memberof UploadsApiSmallFile
    */
    readonly fields?: Array<string>
    
    /**
    * An optional header containing the SHA1 hash of the file to ensure that the file was not corrupted in transit.
    * @type {string}
    * @memberof UploadsApiSmallFile
    */
    readonly contentMd5?: string
    
} & UploadsSmallFileRequest

/**
 * UploadsApiGenerated - object-oriented interface
 * @export
 * @class UploadsApiGenerated
 * @extends {BaseAPI}
 */
export class UploadsApiGenerated extends BaseAPI {
    /**
     * Update a file\'s content. For file sizes over 50MB we recommend using the Chunk Upload APIs.  # Request body order  The `attributes` part of the body must come **before** the `file` part. Requests that do not follow this format when uploading the file will receive a HTTP `400` error with a `metadata_after_file_contents` error code.
     * @summary Upload file version
     * @param {UploadsApiFileContentUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApiGenerated
     */
    public fileContentUpdate(requestParameters: UploadsApiFileContentUpdateRequest, options?: AxiosRequestConfig) {
        return UploadsApiFp(this.configuration).fileContentUpdate(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uploads a small file to Box. For file sizes over 50MB we recommend using the Chunk Upload APIs.  # Request body order  The `attributes` part of the body must come **before** the `file` part. Requests that do not follow this format when uploading the file will receive a HTTP `400` error with a `metadata_after_file_contents` error code.
     * @summary Upload file
     * @param {UploadsApiSmallFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApiGenerated
     */
    public smallFile(requestParameters: UploadsApiSmallFileRequest, options?: AxiosRequestConfig) {
        return UploadsApiFp(this.configuration).smallFile(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
