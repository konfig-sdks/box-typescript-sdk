/* tslint:disable */
/* eslint-disable */
/*
Box Platform API

[Box Platform](https://box.dev) provides functionality to provide access to content stored within [Box](https://box.com). It provides endpoints for basic manipulation of files and folders, management of users within an enterprise, as well as more complex topics such as legal holds and retention policies.

The version of the OpenAPI document: 2.0.0
Contact: devrel@box.com

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ClientError } from '../models';
// @ts-ignore
import { ConflictError } from '../models';
// @ts-ignore
import { MetadataCascadePolicies } from '../models';
// @ts-ignore
import { MetadataCascadePoliciesApplyToChildrenRequest } from '../models';
// @ts-ignore
import { MetadataCascadePoliciesCreatePolicyRequest } from '../models';
// @ts-ignore
import { MetadataCascadePolicy } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * MetadataCascadePoliciesApi - axios parameter creator
 * @export
 */
export const MetadataCascadePoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Force the metadata on a folder with a metadata cascade policy to be applied to all of its children. This can be used after creating a new cascade policy to enforce the metadata to be cascaded down to all existing files within that folder.
         * @summary Force-apply metadata cascade policy to folder
         * @param {string} metadataCascadePolicyId The ID of the cascade policy to force-apply.
         * @param {MetadataCascadePoliciesApplyToChildrenRequest} [metadataCascadePoliciesApplyToChildrenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyToChildren: async (metadataCascadePolicyId: string, metadataCascadePoliciesApplyToChildrenRequest?: MetadataCascadePoliciesApplyToChildrenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metadataCascadePolicyId' is not null or undefined
            assertParamExists('applyToChildren', 'metadataCascadePolicyId', metadataCascadePolicyId)
            const localVarPath = `/metadata_cascade_policies/{metadata_cascade_policy_id}/apply`
                .replace(`{${"metadata_cascade_policy_id"}}`, encodeURIComponent(String(metadataCascadePolicyId !== undefined ? metadataCascadePolicyId : `-metadata_cascade_policy_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: metadataCascadePoliciesApplyToChildrenRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/metadata_cascade_policies/{metadata_cascade_policy_id}/apply',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(metadataCascadePoliciesApplyToChildrenRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new metadata cascade policy that applies a given metadata template to a given folder and automatically cascades it down to any files within that folder.  In order for the policy to be applied a metadata instance must first be applied to the folder the policy is to be applied to.
         * @summary Create metadata cascade policy
         * @param {MetadataCascadePoliciesCreatePolicyRequest} [metadataCascadePoliciesCreatePolicyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy: async (metadataCascadePoliciesCreatePolicyRequest?: MetadataCascadePoliciesCreatePolicyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metadata_cascade_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: metadataCascadePoliciesCreatePolicyRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/metadata_cascade_policies',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(metadataCascadePoliciesCreatePolicyRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific metadata cascade policy assigned to a folder.
         * @summary Get metadata cascade policy
         * @param {string} metadataCascadePolicyId The ID of the metadata cascade policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyAssignedToFolder: async (metadataCascadePolicyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metadataCascadePolicyId' is not null or undefined
            assertParamExists('getPolicyAssignedToFolder', 'metadataCascadePolicyId', metadataCascadePolicyId)
            const localVarPath = `/metadata_cascade_policies/{metadata_cascade_policy_id}`
                .replace(`{${"metadata_cascade_policy_id"}}`, encodeURIComponent(String(metadataCascadePolicyId !== undefined ? metadataCascadePolicyId : `-metadata_cascade_policy_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/metadata_cascade_policies/{metadata_cascade_policy_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all the metadata cascade policies that are applied to a given folder. This can not be used on the root folder with ID `0`.
         * @summary List metadata cascade policies
         * @param {string} folderId Specifies which folder to return policies for. This can not be used on the root folder with ID &#x60;0&#x60;.
         * @param {string} [ownerEnterpriseId] The ID of the enterprise ID for which to find metadata cascade policies. If not specified, it defaults to the current enterprise.
         * @param {string} [marker] Defines the position marker at which to begin returning results. This is used when paginating using marker-based pagination.  This requires &#x60;usemarker&#x60; to be set to &#x60;true&#x60;.
         * @param {number} [offset] The offset of the item at which to begin the response.  Queries with offset parameter value exceeding 10000 will be rejected with a 400 response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (folderId: string, ownerEnterpriseId?: string, marker?: string, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('list', 'folderId', folderId)
            const localVarPath = `/metadata_cascade_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)
            if (folderId !== undefined) {
                localVarQueryParameter['folder_id'] = folderId;
            }

            if (ownerEnterpriseId !== undefined) {
                localVarQueryParameter['owner_enterprise_id'] = ownerEnterpriseId;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/metadata_cascade_policies',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a metadata cascade policy.
         * @summary Remove metadata cascade policy
         * @param {string} metadataCascadePolicyId The ID of the metadata cascade policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePolicy: async (metadataCascadePolicyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metadataCascadePolicyId' is not null or undefined
            assertParamExists('removePolicy', 'metadataCascadePolicyId', metadataCascadePolicyId)
            const localVarPath = `/metadata_cascade_policies/{metadata_cascade_policy_id}`
                .replace(`{${"metadata_cascade_policy_id"}}`, encodeURIComponent(String(metadataCascadePolicyId !== undefined ? metadataCascadePolicyId : `-metadata_cascade_policy_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2Security required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2Security", [], configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/metadata_cascade_policies/{metadata_cascade_policy_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetadataCascadePoliciesApi - functional programming interface
 * @export
 */
export const MetadataCascadePoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetadataCascadePoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * Force the metadata on a folder with a metadata cascade policy to be applied to all of its children. This can be used after creating a new cascade policy to enforce the metadata to be cascaded down to all existing files within that folder.
         * @summary Force-apply metadata cascade policy to folder
         * @param {MetadataCascadePoliciesApiApplyToChildrenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applyToChildren(requestParameters: MetadataCascadePoliciesApiApplyToChildrenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const metadataCascadePoliciesApplyToChildrenRequest: MetadataCascadePoliciesApplyToChildrenRequest = {
                conflict_resolution: requestParameters.conflict_resolution
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.applyToChildren(requestParameters.metadataCascadePolicyId, metadataCascadePoliciesApplyToChildrenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new metadata cascade policy that applies a given metadata template to a given folder and automatically cascades it down to any files within that folder.  In order for the policy to be applied a metadata instance must first be applied to the folder the policy is to be applied to.
         * @summary Create metadata cascade policy
         * @param {MetadataCascadePoliciesApiCreatePolicyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicy(requestParameters: MetadataCascadePoliciesApiCreatePolicyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataCascadePolicy>> {
            const metadataCascadePoliciesCreatePolicyRequest: MetadataCascadePoliciesCreatePolicyRequest = {
                folder_id: requestParameters.folder_id,
                scope: requestParameters.scope,
                templateKey: requestParameters.templateKey
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicy(metadataCascadePoliciesCreatePolicyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a specific metadata cascade policy assigned to a folder.
         * @summary Get metadata cascade policy
         * @param {MetadataCascadePoliciesApiGetPolicyAssignedToFolderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyAssignedToFolder(requestParameters: MetadataCascadePoliciesApiGetPolicyAssignedToFolderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataCascadePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyAssignedToFolder(requestParameters.metadataCascadePolicyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of all the metadata cascade policies that are applied to a given folder. This can not be used on the root folder with ID `0`.
         * @summary List metadata cascade policies
         * @param {MetadataCascadePoliciesApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(requestParameters: MetadataCascadePoliciesApiListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataCascadePolicies>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(requestParameters.folderId, requestParameters.ownerEnterpriseId, requestParameters.marker, requestParameters.offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a metadata cascade policy.
         * @summary Remove metadata cascade policy
         * @param {MetadataCascadePoliciesApiRemovePolicyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePolicy(requestParameters: MetadataCascadePoliciesApiRemovePolicyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removePolicy(requestParameters.metadataCascadePolicyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetadataCascadePoliciesApi - factory interface
 * @export
 */
export const MetadataCascadePoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetadataCascadePoliciesApiFp(configuration)
    return {
        /**
         * Force the metadata on a folder with a metadata cascade policy to be applied to all of its children. This can be used after creating a new cascade policy to enforce the metadata to be cascaded down to all existing files within that folder.
         * @summary Force-apply metadata cascade policy to folder
         * @param {MetadataCascadePoliciesApiApplyToChildrenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyToChildren(requestParameters: MetadataCascadePoliciesApiApplyToChildrenRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.applyToChildren(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new metadata cascade policy that applies a given metadata template to a given folder and automatically cascades it down to any files within that folder.  In order for the policy to be applied a metadata instance must first be applied to the folder the policy is to be applied to.
         * @summary Create metadata cascade policy
         * @param {MetadataCascadePoliciesApiCreatePolicyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy(requestParameters: MetadataCascadePoliciesApiCreatePolicyRequest, options?: AxiosRequestConfig): AxiosPromise<MetadataCascadePolicy> {
            return localVarFp.createPolicy(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific metadata cascade policy assigned to a folder.
         * @summary Get metadata cascade policy
         * @param {MetadataCascadePoliciesApiGetPolicyAssignedToFolderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyAssignedToFolder(requestParameters: MetadataCascadePoliciesApiGetPolicyAssignedToFolderRequest, options?: AxiosRequestConfig): AxiosPromise<MetadataCascadePolicy> {
            return localVarFp.getPolicyAssignedToFolder(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all the metadata cascade policies that are applied to a given folder. This can not be used on the root folder with ID `0`.
         * @summary List metadata cascade policies
         * @param {MetadataCascadePoliciesApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: MetadataCascadePoliciesApiListRequest, options?: AxiosRequestConfig): AxiosPromise<MetadataCascadePolicies> {
            return localVarFp.list(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a metadata cascade policy.
         * @summary Remove metadata cascade policy
         * @param {MetadataCascadePoliciesApiRemovePolicyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePolicy(requestParameters: MetadataCascadePoliciesApiRemovePolicyRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removePolicy(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for applyToChildren operation in MetadataCascadePoliciesApi.
 * @export
 * @interface MetadataCascadePoliciesApiApplyToChildrenRequest
 */
export type MetadataCascadePoliciesApiApplyToChildrenRequest = {
    
    /**
    * The ID of the cascade policy to force-apply.
    * @type {string}
    * @memberof MetadataCascadePoliciesApiApplyToChildren
    */
    readonly metadataCascadePolicyId: string
    
} & MetadataCascadePoliciesApplyToChildrenRequest

/**
 * Request parameters for createPolicy operation in MetadataCascadePoliciesApi.
 * @export
 * @interface MetadataCascadePoliciesApiCreatePolicyRequest
 */
export type MetadataCascadePoliciesApiCreatePolicyRequest = {
    
} & MetadataCascadePoliciesCreatePolicyRequest

/**
 * Request parameters for getPolicyAssignedToFolder operation in MetadataCascadePoliciesApi.
 * @export
 * @interface MetadataCascadePoliciesApiGetPolicyAssignedToFolderRequest
 */
export type MetadataCascadePoliciesApiGetPolicyAssignedToFolderRequest = {
    
    /**
    * The ID of the metadata cascade policy.
    * @type {string}
    * @memberof MetadataCascadePoliciesApiGetPolicyAssignedToFolder
    */
    readonly metadataCascadePolicyId: string
    
}

/**
 * Request parameters for list operation in MetadataCascadePoliciesApi.
 * @export
 * @interface MetadataCascadePoliciesApiListRequest
 */
export type MetadataCascadePoliciesApiListRequest = {
    
    /**
    * Specifies which folder to return policies for. This can not be used on the root folder with ID `0`.
    * @type {string}
    * @memberof MetadataCascadePoliciesApiList
    */
    readonly folderId: string
    
    /**
    * The ID of the enterprise ID for which to find metadata cascade policies. If not specified, it defaults to the current enterprise.
    * @type {string}
    * @memberof MetadataCascadePoliciesApiList
    */
    readonly ownerEnterpriseId?: string
    
    /**
    * Defines the position marker at which to begin returning results. This is used when paginating using marker-based pagination.  This requires `usemarker` to be set to `true`.
    * @type {string}
    * @memberof MetadataCascadePoliciesApiList
    */
    readonly marker?: string
    
    /**
    * The offset of the item at which to begin the response.  Queries with offset parameter value exceeding 10000 will be rejected with a 400 response.
    * @type {number}
    * @memberof MetadataCascadePoliciesApiList
    */
    readonly offset?: number
    
}

/**
 * Request parameters for removePolicy operation in MetadataCascadePoliciesApi.
 * @export
 * @interface MetadataCascadePoliciesApiRemovePolicyRequest
 */
export type MetadataCascadePoliciesApiRemovePolicyRequest = {
    
    /**
    * The ID of the metadata cascade policy.
    * @type {string}
    * @memberof MetadataCascadePoliciesApiRemovePolicy
    */
    readonly metadataCascadePolicyId: string
    
}

/**
 * MetadataCascadePoliciesApiGenerated - object-oriented interface
 * @export
 * @class MetadataCascadePoliciesApiGenerated
 * @extends {BaseAPI}
 */
export class MetadataCascadePoliciesApiGenerated extends BaseAPI {
    /**
     * Force the metadata on a folder with a metadata cascade policy to be applied to all of its children. This can be used after creating a new cascade policy to enforce the metadata to be cascaded down to all existing files within that folder.
     * @summary Force-apply metadata cascade policy to folder
     * @param {MetadataCascadePoliciesApiApplyToChildrenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataCascadePoliciesApiGenerated
     */
    public applyToChildren(requestParameters: MetadataCascadePoliciesApiApplyToChildrenRequest, options?: AxiosRequestConfig) {
        return MetadataCascadePoliciesApiFp(this.configuration).applyToChildren(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new metadata cascade policy that applies a given metadata template to a given folder and automatically cascades it down to any files within that folder.  In order for the policy to be applied a metadata instance must first be applied to the folder the policy is to be applied to.
     * @summary Create metadata cascade policy
     * @param {MetadataCascadePoliciesApiCreatePolicyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataCascadePoliciesApiGenerated
     */
    public createPolicy(requestParameters: MetadataCascadePoliciesApiCreatePolicyRequest, options?: AxiosRequestConfig) {
        return MetadataCascadePoliciesApiFp(this.configuration).createPolicy(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific metadata cascade policy assigned to a folder.
     * @summary Get metadata cascade policy
     * @param {MetadataCascadePoliciesApiGetPolicyAssignedToFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataCascadePoliciesApiGenerated
     */
    public getPolicyAssignedToFolder(requestParameters: MetadataCascadePoliciesApiGetPolicyAssignedToFolderRequest, options?: AxiosRequestConfig) {
        return MetadataCascadePoliciesApiFp(this.configuration).getPolicyAssignedToFolder(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all the metadata cascade policies that are applied to a given folder. This can not be used on the root folder with ID `0`.
     * @summary List metadata cascade policies
     * @param {MetadataCascadePoliciesApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataCascadePoliciesApiGenerated
     */
    public list(requestParameters: MetadataCascadePoliciesApiListRequest, options?: AxiosRequestConfig) {
        return MetadataCascadePoliciesApiFp(this.configuration).list(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a metadata cascade policy.
     * @summary Remove metadata cascade policy
     * @param {MetadataCascadePoliciesApiRemovePolicyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataCascadePoliciesApiGenerated
     */
    public removePolicy(requestParameters: MetadataCascadePoliciesApiRemovePolicyRequest, options?: AxiosRequestConfig) {
        return MetadataCascadePoliciesApiFp(this.configuration).removePolicy(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
